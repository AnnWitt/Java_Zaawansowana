enkapsulacja (hermetyzacja) - ukruwanie pol i metod przed niezamierzonym użyciem
dla nich poslugujemy sie getterami i settery aby moxns bylo jak najwiecej zrobic
prywatne

private
public
domyslne - dla pakietu
protected - dla pakietu oraz klas dziedziczących (zadziala tez jeżeli klasa w innym pakiecie)

stos i sterta
Sterta - przechowywanie obiektw, uporzadkowany struikturowo
Stos -  referencji oraz typow prymitywnych, nieuporzadkowany

String pool - przechowywane litteralow typu string w stercie, do optymalizacji String
string jest tworzony na koniec a nie np po kazdej iteracji pętli

tworzenie obiektu  na stercie np ma referencje do sterty, null jak zmienna na nic nie
wskazuje na stosie

np
Pies burek=new Pies
Pies burek2=burek -> wskazuje na to samo miejsce na stosie

garbage collector (wewnetrzny program javy)
przechodzi po stercie i szuka obiektow do ktorych nie ma referencji. Nie ma wiec mozliwosci
"oszyskania", nie usuwa tylko oznacza jako "wolny do zapisu" (ten sam adres fizyczny)

String pool ->
String ala="Ala"
String ala2="Ala"
sprawdza najpierw czy w string poolu na stos juz o tej tresci i wskazuje na to samo miejsce
aby nie marnowac

Jezeli by bylo za pomocą konstruktora to jest Tworxony nowy obiekt na stosie. Nie zachodza
te optymalizacji, nie szuka w basenie. Dlatego niewskazane jest tworzenie za pomoca
konstruktora bo niepotrzebnie zajmuje miejsce. Wskazuje na inny obiekt o tej samej wartosci
ale nie ma to tu znaczenia. Nie ma optymalnego referencji,

new String
Tworzy obiekt i dodatkowo dokleja do poola - niewskazane

Typy wyliczeniowe
ENUM - nowy typ danych z okreslonymi wartosciami (wielka litera)
moga posiacac konstruktory, metody, pola ale nie mozna bezposrednio wywolac konstruktora
można w switch oraz porownac ==
enum robimy osobno od maina (osobna "klasa")
Bilet normalny=Bilet.NORMALNY (bez new tj bez konstruktora), zmienna typu enuma


Dziedziczenie - slowo extends
Klasa dziedzicząca (podklasa) dziedziczy pola i metody klasy nadrzędnej (nadklasy)
•Klasa Object jest klasą ogólną po której dziedziczy (niejawnie) każda inna klasa
•Podklasa może dziedziczyć tylko po 1 klasie
•Ale każda podklasa może mieć kolejną podklasę

nie mozna dziedzicic po wielu klasach na raz  (jawnie)

np public class Mammal extends Animal

super(name) odwolanie do "rodzica" tj polam, konstruktor klasy nadrzednej
konstruktor musi pasowac do nadrzednego

gdy nie podoba nam się to co mamy "w spadku"
@Override - zachowuje swoja niezaleznosc w klasie podrzednej
użyte nad metodą aby narzucic swoja wartosc
jeżeli damy przed metoda, której nie ma u rodzica to rzuci bląd

hashcode (wazny przy kolekcjach) / equals
Double.compare (porownanie dwoch i zwrocenie czy sa rowne

gfdy nie chcemy aby dziedziczono - uzywamy final (class/method/zmienna) (np aby ktos nie poznal
 wartosci zmiennej

 class - nie mozna dziedziczyc
 method - nie mozna nadpisac (nie zadziała override)
 zmienna - nie można zmienić referencji (referencja, sama wartosc zmienic mozna)

 String domyhslnie jest finalny, po nim nie mozna dziedziczych (aby nie mozna było go "podrobić"
 np na okolicznosc haseł

 final np do stałych aby nie zmieniaja