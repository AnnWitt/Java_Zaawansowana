Operacje I/O (pracuje na strumieniach ale danych, nie tym co wczesnij),
stream api<>stream - rozne pojecia
new I/O (korzysta z buforów, roboczy obszar, umozliwia np cofanie

java.io - wprowadza klasy odpowiadzialne za oeracje na strumienach
java.nio - na wejsciu.wyjsciu, bufofory

korzystjac z read/write blokujemy wykonanie programu (jak zawiera dzo to soiwania)
probl;em blokowania wątków, wielowątkowe już new

FIleInpSream in = new FIleInpSream("user.txt")
while ((c=in.read())!=-1 {
out.wrote(c);
}

nie zawsze nio lepsze, jak duzy plik to lepiej na io bo na nio robi sie ogromny bufor

przy pracy musza byc wyjatki (w io)
problemy braku pliku, problemu z zaczytem

try catch przydaje sie finally (gdy otworxylidmy in i jest <> null to go zamykamy
in.close
zużywamy coraz wiecej pamieci bez tego bo "lapiemy kolejne plik". Inny watek nie
moze sie dostac do tego pliku, strumienie trzebs zamykać po to finally. Bez wzgledu
na to czy znalezliusmy czy nie to musimy zrobic close

mozna try with resourcws aby zamykal z automaty  - implements Closable
(screen ze slacka porownanie.png) => dwa sposoby

https://java.pl.sdacademy.pro/_slides/java_zaawansowana/java_io.html#/

try {
in=new FileInputStream(uset.txt)
out=new FileOutputStream(user_output.txt)

} catch (FileNotFoundException s) {
e.printStackTrace();
} finally {
close.in
}

te pliki umieszczamy w resources
prawy myszy i patch
C:\Users\Anna_\IdeaProjects\JavaZaawansowana\src\main\resources\user.txt
resources/user.txt (z content)

maven/ lifecykle, clean i instal

//Reader - FileReader
/Writer - FileWriter

tu jest strumien znaków, to co bylo wczesniej to bylo do strumienia danych


   out = new FileWriter("C:\\Users\\Anna_" +
                    "\\IdeaProjects\\JavaZaawansowana\\src\\main\\resources" +
                    "\\user_output.txt");*/ //wtedy nadpisze
            out = new FileWriter("C:\\Users\\Anna_" +
                    "\\IdeaProjects\\JavaZaawansowana\\src\\main\\resources" +
                    "\\user_output.txt",true); //wtedy dopisze a nie nadpisze

                    --------------------------
                    buforowanie danych

////////////////////////////////////////////////// bufory i kanały
nio - clean/flip/rewind bufor
Channels - reprezentavcja twartego polaczenia np z zewn urzadzeniem np drukarka/portem
/innym komponentem
umozliwia jedna lub wiecej operacji,optymalizuje, zamyka

kanal moze zawierac bufor ale nie musi/ bezpieczne dla wielowątkowosci
kanal "zarzadza" buforem

nio - pozwala na wiele kanalow, przydzielone rozne wątku
https://java.pl.sdacademy.pro/_slides/java_zaawansowana/java_io.html#/8
//Path jest interfejsem,



//---------------------------
Serializacja i deserializacja

zamiana obiektu na dane /dane na obiekt
jak wywala notserializableexception to w klasie implements Serializable

/////////////////////////////
wspolbiezne (1 i 2 sie wymieniaja zasobami
rownolegle (1 watek i drugi razem w nim

proces sklada się z wątków
https://java.pl.sdacademy.pro/_slides/java_zaawansowana/programowanie_wspolbiezne_i_rownolegle.html#/
Thread watek wykonania w probramie (extends Thread)
dziedziczenie po Thread albo z interfejsu Runnable

public class HttpAction extends Thread {
    @Override
    public void run() {
        //Send http request
    }
}
class HttpClient {
    public static void main(String[] args) {
        HttpAction httpAction = new HttpAction();
        httpAction.start();//uruchomienie wątku
    }
}


wątek stany

wait czeka na akcje
sleep na okreslony czas


Thread.currentthread().getid()

moga sie ieszac watki i sobie wchodza a parade
nie da sie przewidziec, który kiedy przwejmie zasoby

w ramach jednego watku idzie po kolei ale jak ida 2,3 watki to moga
byc przemieszane

Thread t1=new Thread(new Runnable())
t1.start()

zatrzymanie atku - jest na to metoda stop ale nie powinnismy z nej korzystac
jest interrupt

synchronized - gdy kilka watkow dotykaja jednej zmiennej to tylko jedno wchodzi na raz
mpzna blok kopdu albo metodę
public synchronized void run()